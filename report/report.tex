\documentclass[format=sigconf]{acmart}

\usepackage{algorithm}
\usepackage{algorithmic}

\begin{document}

\title{CSE-6140 Final Project}
\author{Filip Gajowniczek}
\author{Nick Dargi}

% This template is probably useful
% https://www.overleaf.com/latex/templates/acm-conference-proceedings-master-template/pnrfvrrdbfwt

\section{Introduction}
The Traveling Salesman Problem (TSP) is an NP-Complete computational problem which has been studied extensively for several decades \cite{laporte_1992}. In this paper, techniques for obtaining/approximating the solution to the symmetric Traveling Salesman Problem are developed and compared. A branch-and-bound algorithm using a minimum spanning tree to inform a lower bound on subproblems is presented; which, given enough time, produces an exact solution to the problem. The use of approximation algorithms proves more prudent for larger problems while sacrificing solution quality; a fact which motivated the development of a greedy local search algorithm which explores 1-exchange neighbors.
\section*{Problem Definition}
The symmetric traveling salesman optimization problem is formalized as follows:\\
Given a connected undirected graph G consisting of n nodes,$\{v_0, \hdots, v_{n-1}\}$ , with edge weights $d_{ij}$ between nodes i and j.
Find a Hamiltonian Cycle, a path P* where each node has degree 2, with minimum weight.\\
In this paper, nodes in a 2 dimensional space were considered: $v_i = \begin{bmatrix}
v_{ix} \\ v_{iy} 
\end{bmatrix} \in \mathbb{R}^2 \quad \forall i \in [0,n-1]$\\
With edge weights calculated using the Euclidean distance: $e_{ij} = || v_i, v_j ||_2 = \sqrt{(v_{ix}-v_{jx})^2 + ((v_{iy}-v_{jy}^2)} \quad \forall i\neq j, i \in [0,n-1], j \in [0,n-1]$\\
The solution is an element in the set of vertex sequences which are Hamiltonian Cycles given by:\\
$\mathcal{H} = \{ (v_i)_{i=0}^{n-1} : v_0 = v_{n-1}, v_i \neq v_j \quad \forall i,j \in [0,n-1]\}$\\
The symmetric TSP is given by following optimization problem:\\ 
$P^*=(v^*_i)_{i=0}^{n-1} =\quad  \stackrel{argmin}{(v_i)_{i=0}^{n-1} \in \mathcal{H}} \quad \sum_{i=0}^{n-2} ||v_i, v_{i+1} || + ||v_0, v_{n-1} || $
\section*{Related Work}
\section*{Algorithms}
\begin{algorithm}
	\caption{  BnB( $\{v_0, \hdots, v_{n-1}\}$ ): Find minimum cost Hamiltonian Cycle for euclidean distances}
	\begin{algorithmic} 
		\STATE Data: $\{v_0, \hdots, v_{n-1}\}$ set of 2-D points
		\FORALL{ Unordered Pairs $\{i,j\}$}
			\STATE Construct edge $e = (v_i, v_j, d_{ij})$
			\STATE Add e to list E of edges in increasing weight order: $E = E \cup \{e\}$
		\ENDFOR
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\caption{  2-Opt Local Search( $\{v_0, \hdots, v_{n-1}\}$ ): Approximate the minimum cost Hamiltonian Cycle for euclidean distances}
	\begin{algorithmic} 
		\STATE Data: $\{v_0, \hdots, v_{n-1}\}$ set of 2-D points
		\FORALL{ Unordered Pairs $\{i,j\}$}
			\STATE Construct edge $e = (v_i, v_j, d_{ij})$
			\STATE Add e to list E of edges in increasing weight order: $E = E \cup \{e\}$
		\ENDFOR
		\WHILE{Unassigned nodes in $v$}
			\STATE Assign Nodes to Route based on Greedy Nearest Neighbor implementation
		\ENDWHILE
		\FOR{i = 1 to length(Route Matrix)}
			\FOR{j = i+1 to length(Route Matrix)}
				\STATE reverse route[i] to route[j] and add it to newroute[i] to newroute[j]
				\IF{cost(newroute) < cost(route)}
					\STATE route \leftarrow newroute
				\ENDIF
			\ENDFOR
		\ENDFOR
		
	\end{algorithmic}
\end{algorithm}
\section*{Empirical Evaluation}
\section*{Discussion}
\section*{Conclusion}
\bibliographystyle{ACM-Reference-Format}
\bibliography{bibfile}
\end{document}